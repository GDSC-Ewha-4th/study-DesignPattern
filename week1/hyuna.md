# 1. 디자인 패턴 소개와 전략 패턴

</br>

### 📌 상속의 단점, 서브 클래스에서 코드가 중복된다.
상속이 코드를 재사용한다는 점에서는 좋지만 오버라이드 시에 코드가 중복되어 비효일적일수도 있다.


### 📌 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
클래스 내에서 단순히 구현만 하기보다는 인터페이스로 뺄 수 있는 건 빼고 캡슐화를 하면서 프로그래밍하라는 의미다.

책으 앞 부분에서도 동일하게 인터페이스르 구현하여 개발하긴 했지만 이 방법을 저자느 멍청하다고 표현했다.
그 이유는 앞 쪽에서 구현한 방법이 인터페이스를 그냥 필요하다고 생각될 때 클래스마다 다 만들어서 썼기에 비효율적이기 때문이다.

이 디자인 원칙에서 '인터페이스에 맞춰서 하라'는 얘기는 인터페이스를 미리 잘 구성해놓고 여기에서 필요한 것만 가져다 쓰는, 진짜 말그대로 '인터페이스에 맞춰서' 구현하라는 의미인 것이다.

변수나 객체를 그때 그때 만들어 쓰면 지금 구현중인 바로 그 오리에만 쓸 수 있는데 이 디자인 원칙대로 미리 만들어놓고 필요한 것만 빼서 쓰면 다르 비슷하 거위한테도 쓸 수 있다는 것이다!

</br>

### 📌 모든 상황에 객체를 미리 구현해두는 것이 효율적인가?
48페이지처럼 게터를 미리 만들어놓고 나중에 구현된 객체를 실행시켜서 대입하는게 맞는지, 아니면 57페이지처럼 하나 정도 나오는 것은 그냥 쓰는게 맞는지. 어떤 게 더 효율적일까?

57페이지의 경우에는 한번 보여주고 말 코드이고 반복적이지는 않기 때문에 굳이 게터까지는 만들지 않은 것 같다.
따라서 '반복될 거면' 게터를 만드는 게 낫다는 것이 토의의 결론이었다.

</br>

### 📌 오리 행동 통합하기
단순한 fly()랑 quack()을 duck 클래스에 넣는게 아니고 performfly()같은 메소드를 만들어서, 그 메소드 안에서 flybehavior로 참조되는 객체에 행동을 위임한다. (훨훨 난다던지 펄펄 난다든지..)
그래서 이렇게 클래스랑 메서드를 구현하면 뒤에 상속하는 말라드덕같은 클래스에서는 덕클래스의 행동 인스턴스 변수를 상속받아 quackbehavior를 구현한 형식의 새로운 인스턴스르 대입하게 된다.

헷갈리지 말아야 할 것은, performquack() 에서는 quackbehavior.quack()을 똑같이 써주지만, 나중에 상속할 때 그 인스터스 변수에 대입값을 꽉이 아닌 빽 등 다른 것들로 바꿔주기 때문에 그 quack() 메소드의 내용 역시 바뀌게 되는 것이다. 
그래서 코드 전체를 바꿔줄 필요가 없으므로 재사용성이 높은, 효율적인 코드가 되는 것이다.

