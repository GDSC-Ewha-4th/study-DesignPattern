## 측정치를 옵저버에게 직접 전달하는 문제를 해결할 수 있는 다른 접근법에는 무엇이 있을까?
옵저버를 구현하는 방식에는 크게 두 가지가 있다.

- Push : 주제가 옵저버로 데이터를 보냄
- Pull : 옵저버가 주제로부터 데이터를 당겨옴

이 두 가지 관점에서 생각해보면 예제에서 만들어 놓은 `WeatherData` 디자인은 전자의 방식으로, 하나의 데이터만 갱신해도 되는 상황에서도 `update()` 메소드에 모든 데이터를 보내도록 되어 있다. 이는 캡슐화 원칙에 어긋나며, 때문에 새로운 데이터 값을 추가한다면 대부분의 `update()` 메소드에서 새로 추가된 데이터를 쓰지 않더라도 모든 디스플레이에 있는 `update()`의 값을 바꿔야 할 것이다.
이러한 번거로움을 해결하고자, 측정치를 직접 전달하는게 아니라 갱신된 상태만을 전달해서 갱신되었을 때 옵저버가 필요한 데이터를 골라서 가져가도록(Pull) 만드는 방법이 더 좋다.

</br>

## 실행 중에 하나의 옵저버를 다른 옵저버로 바꿔도 주제는 계속해서 다른 옵저버에 데이터를 보낼 수 있다.
옵저버를 바꿔도 주제는 계속해서 데이터를 보낼 수 있다. 구독자가 바뀌어도 출판사에서는 여전히 새로운 구독자 명단을 받아 인쇄물을 보낼 수 있는 것처럼, 주제는 인터페이스를 구현하는 객체의 목록에만 의존하므로 그 객체가 어떤 값으로 바뀌든 상관없으며 심지어는 제거해도 무관하다.

</br>

## 발행-구독 패턴(Publisher-Subscriber Pattern)이란?
이 장에서 다루는 옵저버 패턴은 주제가 옵저버를 몰라도 되는 구조다. 정확히는 옵저버의 존재만 알면 되며 그 안에서 어떻게 인터페이스가 구현되어 있는지는 알 필요가 없다.
반면 발행-구독 패턴은 두 개념이 완전히 분리된 패턴이다. 발행자와 구독자 사이에 미들웨어가 존재하여 브로커 역할을 하는데, 이 덕분에 서로가 서로를 모르지만 정보를 전달받을 수 있으며, 심지어 구독자는 발행자의 정보를 선택적으로 전달받을 수도 있다.
이는 디자인 원칙적인 면에서 좀 더 `느슨한 결합`을 사용하므로 더 좋은 디자인이라고 생각할 수 있다.

발행-구독 패턴의 특징이자 장점은 아래와 같다.
- 비동기(Asynchronous) : 큐에 넣어서 나중에 처리 가능
- 비동조(Decoupling) : 앱과 분리 가능
- 탄력성(Resilience) : 일부 실패가 전체에 영향x
- 과잉(Redunadancy) : 실패할 경우 재실행 가능
- 보증(Guarantees) : 작업 처리 확인 가능
- 확장성(Scalable) : 다수 프로세스들이 큐에 메시지 보내기 가능

이렇게 좋은 패턴이 있는데도 옵저버 패턴을 쓰는 이유는 무엇일까?

1차적으로는 발행-구독 패턴의 미들웨어에서 사용하는 메시지 큐에 단점이 존재한다.
- '큐'이기 때문에 사용자가 많아지거나, 데이터가 많아지면 요청에 대한 응답이 늦어지게 된다.
- 즉 과도한 트래픽이 몰리게 되면, 대기 시간 지연으로 인해 서비스가 망가질 위험이 있다.

그리고 가장 결정적인 점은 옵저버 패턴은 동기방식으로 동작하며, 발행-구독 패턴은 비동기적으로 동작한다는 것이다. 따라서 동기와 비동기의 차이에 따라 취사 선택할 수 있다.
